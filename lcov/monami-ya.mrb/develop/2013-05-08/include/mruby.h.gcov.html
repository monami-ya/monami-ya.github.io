<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - monami-ya.mrb_develop.info - include/mruby.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">include</a> - mruby.h<span style="font-size: 80%;"> (source / <a href="mruby.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">monami-ya.mrb_develop.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2013-05-08</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            : ** mruby - An embeddable Ruby implementation
<span class="lineNum">       3 </span>            : **
<span class="lineNum">       4 </span>            : ** Copyright (c) mruby developers 2010-2013
<span class="lineNum">       5 </span>            : **
<span class="lineNum">       6 </span>            : ** Permission is hereby granted, free of charge, to any person obtaining
<span class="lineNum">       7 </span>            : ** a copy of this software and associated documentation files (the
<span class="lineNum">       8 </span>            : ** &quot;Software&quot;), to deal in the Software without restriction, including
<span class="lineNum">       9 </span>            : ** without limitation the rights to use, copy, modify, merge, publish,
<span class="lineNum">      10 </span>            : ** distribute, sublicense, and/or sell copies of the Software, and to
<span class="lineNum">      11 </span>            : ** permit persons to whom the Software is furnished to do so, subject to
<span class="lineNum">      12 </span>            : ** the following conditions:
<span class="lineNum">      13 </span>            : **
<span class="lineNum">      14 </span>            : ** The above copyright notice and this permission notice shall be
<span class="lineNum">      15 </span>            : ** included in all copies or substantial portions of the Software.
<span class="lineNum">      16 </span>            : **
<span class="lineNum">      17 </span>            : ** THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
<span class="lineNum">      18 </span>            : ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
<span class="lineNum">      19 </span>            : ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
<span class="lineNum">      20 </span>            : ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
<span class="lineNum">      21 </span>            : ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
<span class="lineNum">      22 </span>            : ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
<span class="lineNum">      23 </span>            : ** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
<span class="lineNum">      24 </span>            : **
<span class="lineNum">      25 </span>            : ** [ MIT license: http://www.opensource.org/licenses/mit-license.php ]
<span class="lineNum">      26 </span>            : */
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #ifndef MRUBY_H
<span class="lineNum">      29 </span>            : #define MRUBY_H
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #if defined(__cplusplus)
<span class="lineNum">      32 </span>            : extern &quot;C&quot; {
<span class="lineNum">      33 </span>            : #endif
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #include &quot;mrbconf.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #include &quot;mruby/value.h&quot;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : typedef uint32_t mrb_code;
<span class="lineNum">      40 </span>            : typedef uint32_t mrb_aspec;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : struct mrb_state;
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : typedef void* (*mrb_allocf) (struct mrb_state *mrb, void*, size_t, uintptr_t ud);
<span class="lineNum">      45 </span>            : typedef void (*mrb_panic_hook) (struct mrb_state *mrb);
<span class="lineNum">      46 </span>            : typedef int (*mrb_log_printer)(const char *);
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : #ifndef MRB_ARENA_SIZE
<span class="lineNum">      49 </span>            : #define MRB_ARENA_SIZE 100
<span class="lineNum">      50 </span>            : #endif
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : typedef struct {
<span class="lineNum">      53 </span>            :   mrb_sym mid;
<span class="lineNum">      54 </span>            :   struct RProc *proc;
<span class="lineNum">      55 </span>            :   int stackidx;
<span class="lineNum">      56 </span>            :   int nregs;
<span class="lineNum">      57 </span>            :   int argc;
<span class="lineNum">      58 </span>            :   mrb_code *pc;
<span class="lineNum">      59 </span>            :   int acc;
<span class="lineNum">      60 </span>            :   struct RClass *target_class;
<span class="lineNum">      61 </span>            :   int ridx;
<span class="lineNum">      62 </span>            :   int eidx;
<span class="lineNum">      63 </span>            :   struct REnv *env;
<span class="lineNum">      64 </span>            : } mrb_callinfo;
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : enum gc_state {
<span class="lineNum">      67 </span>            :   GC_STATE_NONE = 0,
<span class="lineNum">      68 </span>            :   GC_STATE_MARK,
<span class="lineNum">      69 </span>            :   GC_STATE_SWEEP
<span class="lineNum">      70 </span>            : };
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : enum mrb_log_level {
<span class="lineNum">      73 </span>            :   MRB_LOGGING_NORMAL = 0,
<span class="lineNum">      74 </span>            :   MRB_LOGGING_EXPRESS = 1
<span class="lineNum">      75 </span>            : };
<span class="lineNum">      76 </span>            : #define MRB_LOG_LEVEL_MAX 1
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : typedef struct mrb_state {
<span class="lineNum">      79 </span>            :   void *jmp;
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            :   mrb_panic_hook panic_hook;
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            :   mrb_allocf allocf;
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            :   mrb_value *stack;
<span class="lineNum">      86 </span>            :   mrb_value *stbase, *stend;
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :   mrb_callinfo *ci;
<span class="lineNum">      89 </span>            :   mrb_callinfo *cibase, *ciend;
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :   mrb_code **rescue;
<span class="lineNum">      92 </span>            :   int rsize;
<span class="lineNum">      93 </span>            :   struct RProc **ensure;
<span class="lineNum">      94 </span>            :   int esize;
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            :   struct RObject *exc;
<span class="lineNum">      97 </span>            :   struct iv_tbl *globals;
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :   struct mrb_irep **irep;
<span class="lineNum">     100 </span>            :   size_t irep_len, irep_capa;
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :   mrb_sym init_sym;
<span class="lineNum">     103 </span>            :   struct RObject *top_self;
<span class="lineNum">     104 </span>            :   struct RClass *object_class;
<span class="lineNum">     105 </span>            :   struct RClass *class_class;
<span class="lineNum">     106 </span>            :   struct RClass *module_class;
<span class="lineNum">     107 </span>            :   struct RClass *proc_class;
<span class="lineNum">     108 </span>            :   struct RClass *string_class;
<span class="lineNum">     109 </span>            :   struct RClass *array_class;
<span class="lineNum">     110 </span>            :   struct RClass *hash_class;
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :   struct RClass *float_class;
<span class="lineNum">     113 </span>            :   struct RClass *fixnum_class;
<span class="lineNum">     114 </span>            :   struct RClass *true_class;
<span class="lineNum">     115 </span>            :   struct RClass *false_class;
<span class="lineNum">     116 </span>            :   struct RClass *nil_class;
<span class="lineNum">     117 </span>            :   struct RClass *symbol_class;
<span class="lineNum">     118 </span>            :   struct RClass *kernel_module;
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :   struct heap_page *heaps;
<span class="lineNum">     121 </span>            :   struct heap_page *sweeps;
<span class="lineNum">     122 </span>            :   struct heap_page *free_heaps;
<span class="lineNum">     123 </span>            :   size_t live; /* count of live objects */
<span class="lineNum">     124 </span>            :   struct RBasic *arena[MRB_ARENA_SIZE];
<span class="lineNum">     125 </span>            :   int arena_idx;
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :   enum gc_state gc_state; /* state of gc */
<span class="lineNum">     128 </span>            :   int current_white_part; /* make white object by white_part */
<span class="lineNum">     129 </span>            :   struct RBasic *gray_list; /* list of gray objects */
<span class="lineNum">     130 </span>            :   struct RBasic *variable_gray_list; /* list of objects to be traversed atomically */
<span class="lineNum">     131 </span>            :   size_t gc_live_after_mark;
<span class="lineNum">     132 </span>            :   size_t gc_threshold;
<span class="lineNum">     133 </span>            :   int gc_interval_ratio;
<span class="lineNum">     134 </span>            :   int gc_step_ratio;
<span class="lineNum">     135 </span>            :   mrb_bool gc_disabled:1;
<span class="lineNum">     136 </span>            :   mrb_bool gc_full:1;
<span class="lineNum">     137 </span>            :   mrb_bool is_generational_gc_mode:1;
<span class="lineNum">     138 </span>            :   mrb_bool out_of_memory:1;
<span class="lineNum">     139 </span>            :   size_t majorgc_old_threshold;
<span class="lineNum">     140 </span>            :   struct alloca_header *mems;
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            :   mrb_sym symidx;
<span class="lineNum">     143 </span>            :   struct kh_n2s *name2sym;      /* symbol table */
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : #ifdef ENABLE_DEBUG
<span class="lineNum">     146 </span>            :   void (*code_fetch_hook)(struct mrb_state* mrb, struct mrb_irep *irep, mrb_code *pc, mrb_value *regs);
<span class="lineNum">     147 </span>            : #endif
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :   struct RClass *eException_class;
<span class="lineNum">     150 </span>            :   struct RClass *eStandardError_class;
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :   mrb_log_printer log_printer[MRB_LOG_LEVEL_MAX + 1];
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :   uintptr_t ud; /* auxiliary data */
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            : } mrb_state;
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : typedef mrb_value (*mrb_func_t)(mrb_state *mrb, mrb_value);
<span class="lineNum">     159 </span>            : struct RClass *mrb_define_class(mrb_state *, const char*, struct RClass*);
<span class="lineNum">     160 </span>            : struct RClass *mrb_define_module(mrb_state *, const char*);
<span class="lineNum">     161 </span>            : mrb_value mrb_singleton_class(mrb_state*, mrb_value);
<span class="lineNum">     162 </span>            : void mrb_include_module(mrb_state*, struct RClass*, struct RClass*);
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : void mrb_define_method(mrb_state*, struct RClass*, const char*, mrb_func_t, mrb_aspec);
<span class="lineNum">     165 </span>            : void mrb_define_class_method(mrb_state *, struct RClass *, const char *, mrb_func_t, mrb_aspec);
<span class="lineNum">     166 </span>            : void mrb_define_singleton_method(mrb_state*, struct RObject*, const char*, mrb_func_t, mrb_aspec);
<span class="lineNum">     167 </span>            : void mrb_define_module_function(mrb_state*, struct RClass*, const char*, mrb_func_t, mrb_aspec);
<span class="lineNum">     168 </span>            : void mrb_define_const(mrb_state*, struct RClass*, const char *name, mrb_value);
<span class="lineNum">     169 </span>            : void mrb_undef_method(mrb_state*, struct RClass*, const char*);
<span class="lineNum">     170 </span>            : void mrb_undef_class_method(mrb_state*, struct RClass*, const char*);
<span class="lineNum">     171 </span>            : mrb_value mrb_instance_new(mrb_state *mrb, mrb_value cv);
<span class="lineNum">     172 </span>            : struct RClass * mrb_class_new(mrb_state *mrb, struct RClass *super);
<span class="lineNum">     173 </span>            : struct RClass * mrb_module_new(mrb_state *mrb);
<span class="lineNum">     174 </span>            : int mrb_class_defined(mrb_state *mrb, const char *name);
<span class="lineNum">     175 </span>            : struct RClass * mrb_class_get(mrb_state *mrb, const char *name);
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            : mrb_value mrb_obj_dup(mrb_state *mrb, mrb_value obj);
<span class="lineNum">     178 </span>            : mrb_value mrb_check_to_integer(mrb_state *mrb, mrb_value val, const char *method);
<span class="lineNum">     179 </span>            : int mrb_obj_respond_to(struct RClass* c, mrb_sym mid);
<span class="lineNum">     180 </span>            : struct RClass * mrb_define_class_under(mrb_state *mrb, struct RClass *outer, const char *name, struct RClass *super);
<span class="lineNum">     181 </span>            : struct RClass * mrb_define_module_under(mrb_state *mrb, struct RClass *outer, const char *name);
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : /* required arguments */
<span class="lineNum">     184 </span>            : #define MRB_ARGS_REQ(n)     ((mrb_aspec)((n)&amp;0x1f) &lt;&lt; 18)
<span class="lineNum">     185 </span>            : /* optional arguments */
<span class="lineNum">     186 </span>            : #define MRB_ARGS_OPT(n)     ((mrb_aspec)((n)&amp;0x1f) &lt;&lt; 13)
<span class="lineNum">     187 </span>            : /* mandatory and optinal arguments */
<span class="lineNum">     188 </span>            : #define MRB_ARGS_ARG(n1,n2)   (MRB_ARGS_REQ(n1)|MRB_ARGS_OPT(n2))
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            : /* rest argument */
<span class="lineNum">     191 </span>            : #define MRB_ARGS_REST()     ((mrb_aspec)(1 &lt;&lt; 12))
<span class="lineNum">     192 </span>            : /* required arguments after rest */
<span class="lineNum">     193 </span>            : #define MRB_ARGS_POST(n)    ((mrb_aspec)((n)&amp;0x1f) &lt;&lt; 7)
<span class="lineNum">     194 </span>            : /* keyword arguments (n of keys, kdict) */
<span class="lineNum">     195 </span>            : #define MRB_ARGS_KEY(n1,n2) ((mrb_aspec)((((n1)&amp;0x1f) &lt;&lt; 2) | ((n2)?(1&lt;&lt;1):0)))
<span class="lineNum">     196 </span>            : /* block argument */
<span class="lineNum">     197 </span>            : #define MRB_ARGS_BLOCK()    ((mrb_aspec)1)
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            : /* accept any number of arguments */
<span class="lineNum">     200 </span>            : #define MRB_ARGS_ANY()      ARGS_REST()
<span class="lineNum">     201 </span>            : /* accept no arguments */
<span class="lineNum">     202 </span>            : #define MRB_ARGS_NONE()     ((mrb_aspec)0)
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : /* compatibility macros; will be removed */
<span class="lineNum">     205 </span>            : #define ARGS_REQ(n)         MRB_ARGS_REQ(n)
<span class="lineNum">     206 </span>            : #define ARGS_OPT(n)         MRB_ARGS_OPT(n)
<span class="lineNum">     207 </span>            : #define ARGS_REST()         MRB_ARGS_REST()
<span class="lineNum">     208 </span>            : #define ARGS_POST(n)        MRB_ARGS_POST()
<span class="lineNum">     209 </span>            : #define ARGS_KEY(n1,n2)     MRB_ARGS_KEY(n1,n2)
<span class="lineNum">     210 </span>            : #define ARGS_BLOCK()        MRB_ARGS_BLOCK()
<span class="lineNum">     211 </span>            : #define ARGS_ANY()          MRB_ARGS_ANY()
<span class="lineNum">     212 </span>            : #define ARGS_NONE()         MRB_ARGS_NONE()
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : int mrb_get_args(mrb_state *mrb, const char *format, ...);
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            : mrb_value mrb_funcall(mrb_state*, mrb_value, const char*, int,...);
<span class="lineNum">     217 </span>            : mrb_value mrb_funcall_argv(mrb_state*, mrb_value, mrb_sym, int, mrb_value*);
<span class="lineNum">     218 </span>            : mrb_value mrb_funcall_with_block(mrb_state*, mrb_value, mrb_sym, int, mrb_value*, mrb_value);
<span class="lineNum">     219 </span>            : mrb_sym mrb_intern_cstr(mrb_state*,const char*);
<span class="lineNum">     220 </span>            : mrb_sym mrb_intern2(mrb_state*,const char*,size_t);
<span class="lineNum">     221 </span>            : mrb_sym mrb_intern_str(mrb_state*,mrb_value);
<span class="lineNum">     222 </span>            : mrb_value mrb_check_intern_cstr(mrb_state*,const char*);
<span class="lineNum">     223 </span>            : mrb_value mrb_check_intern(mrb_state*,const char*,size_t);
<span class="lineNum">     224 </span>            : mrb_value mrb_check_intern_str(mrb_state*,mrb_value);
<span class="lineNum">     225 </span>            : const char *mrb_sym2name(mrb_state*,mrb_sym);
<span class="lineNum">     226 </span>            : const char *mrb_sym2name_len(mrb_state*,mrb_sym,size_t*);
<span class="lineNum">     227 </span>            : mrb_value mrb_sym2str(mrb_state*,mrb_sym);
<span class="lineNum">     228 </span>            : mrb_value mrb_str_format(mrb_state *, int, const mrb_value *, mrb_value);
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : /* For backward compatibility. */
<a name="231"><span class="lineNum">     231 </span>            : static inline</a>
<span class="lineNum">     232 </span>            : mrb_sym mrb_intern(mrb_state *mrb,const char *cstr)
<span class="lineNum">     233 </span><span class="lineCov">      34830 : {</span>
<span class="lineNum">     234 </span><span class="lineCov">      34830 :   return mrb_intern_cstr(mrb, cstr);</span>
<span class="lineNum">     235 </span>            : }
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            : void *mrb_malloc(mrb_state*, size_t);
<span class="lineNum">     238 </span>            : void *mrb_calloc(mrb_state*, size_t, size_t);
<span class="lineNum">     239 </span>            : void *mrb_realloc(mrb_state*, void*, size_t);
<span class="lineNum">     240 </span>            : struct RBasic *mrb_obj_alloc(mrb_state*, enum mrb_vtype, struct RClass*);
<span class="lineNum">     241 </span>            : void mrb_free(mrb_state*, void*);
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : mrb_value mrb_str_new(mrb_state *mrb, const char *p, size_t len);
<span class="lineNum">     244 </span>            : mrb_value mrb_str_new_cstr(mrb_state*, const char*);
<span class="lineNum">     245 </span>            : mrb_value mrb_str_new_static(mrb_state *mrb, const char *p, size_t len);
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : mrb_state* mrb_open(void);
<span class="lineNum">     248 </span>            : mrb_state* mrb_open_allocf(mrb_allocf, uintptr_t ud);
<span class="lineNum">     249 </span>            : void mrb_irep_free(mrb_state*, struct mrb_irep*);
<span class="lineNum">     250 </span>            : void mrb_close(mrb_state*);
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : mrb_value mrb_top_self(mrb_state *);
<span class="lineNum">     253 </span>            : mrb_value mrb_run(mrb_state*, struct RProc*, mrb_value);
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : void mrb_p(mrb_state*, mrb_value);
<span class="lineNum">     256 </span>            : mrb_int mrb_obj_id(mrb_value obj);
<span class="lineNum">     257 </span>            : mrb_sym mrb_obj_to_sym(mrb_state *mrb, mrb_value name);
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : int mrb_obj_eq(mrb_state*, mrb_value, mrb_value);
<span class="lineNum">     260 </span>            : int mrb_obj_equal(mrb_state*, mrb_value, mrb_value);
<span class="lineNum">     261 </span>            : int mrb_equal(mrb_state *mrb, mrb_value obj1, mrb_value obj2);
<span class="lineNum">     262 </span>            : mrb_value mrb_Integer(mrb_state *mrb, mrb_value val);
<span class="lineNum">     263 </span>            : mrb_value mrb_Float(mrb_state *mrb, mrb_value val);
<span class="lineNum">     264 </span>            : mrb_value mrb_inspect(mrb_state *mrb, mrb_value obj);
<span class="lineNum">     265 </span>            : int mrb_eql(mrb_state *mrb, mrb_value obj1, mrb_value obj2);
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : void mrb_garbage_collect(mrb_state*);
<span class="lineNum">     268 </span>            : void mrb_incremental_gc(mrb_state *);
<span class="lineNum">     269 </span>            : int mrb_gc_arena_save(mrb_state*);
<span class="lineNum">     270 </span>            : void mrb_gc_arena_restore(mrb_state*,int);
<span class="lineNum">     271 </span>            : void mrb_gc_mark(mrb_state*,struct RBasic*);
<span class="lineNum">     272 </span>            : #define mrb_gc_mark_value(mrb,val) do {\
<span class="lineNum">     273 </span>            :   if (mrb_type(val) &gt;= MRB_TT_OBJECT) mrb_gc_mark((mrb), mrb_basic_ptr(val));\
<span class="lineNum">     274 </span>            : } while (0)
<span class="lineNum">     275 </span>            : void mrb_field_write_barrier(mrb_state *, struct RBasic*, struct RBasic*);
<span class="lineNum">     276 </span>            : #define mrb_field_write_barrier_value(mrb, obj, val) do{\
<span class="lineNum">     277 </span>            :   if ((val.tt &gt;= MRB_TT_OBJECT)) mrb_field_write_barrier((mrb), (obj), mrb_basic_ptr(val));\
<span class="lineNum">     278 </span>            : } while (0)
<span class="lineNum">     279 </span>            : void mrb_write_barrier(mrb_state *, struct RBasic*);
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            : mrb_value mrb_check_convert_type(mrb_state *mrb, mrb_value val, mrb_int type, const char *tname, const char *method);
<span class="lineNum">     282 </span>            : mrb_value mrb_any_to_s(mrb_state *mrb, mrb_value obj);
<span class="lineNum">     283 </span>            : const char * mrb_obj_classname(mrb_state *mrb, mrb_value obj);
<span class="lineNum">     284 </span>            : struct RClass* mrb_obj_class(mrb_state *mrb, mrb_value obj);
<span class="lineNum">     285 </span>            : mrb_value mrb_class_path(mrb_state *mrb, struct RClass *c);
<span class="lineNum">     286 </span>            : mrb_value mrb_convert_type(mrb_state *mrb, mrb_value val, mrb_int type, const char *tname, const char *method);
<span class="lineNum">     287 </span>            : int mrb_obj_is_kind_of(mrb_state *mrb, mrb_value obj, struct RClass *c);
<span class="lineNum">     288 </span>            : mrb_value mrb_obj_inspect(mrb_state *mrb, mrb_value self);
<span class="lineNum">     289 </span>            : mrb_value mrb_obj_clone(mrb_state *mrb, mrb_value self);
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : /* need to include &lt;ctype.h&gt; to use these macros */
<span class="lineNum">     292 </span>            : #ifndef ISPRINT
<span class="lineNum">     293 </span>            : //#define ISASCII(c) isascii((int)(unsigned char)(c))
<span class="lineNum">     294 </span>            : #define ISASCII(c) 1
<span class="lineNum">     295 </span>            : #undef ISPRINT
<span class="lineNum">     296 </span>            : #define ISPRINT(c) (ISASCII(c) &amp;&amp; isprint((int)(unsigned char)(c)))
<span class="lineNum">     297 </span>            : #define ISSPACE(c) (ISASCII(c) &amp;&amp; isspace((int)(unsigned char)(c)))
<span class="lineNum">     298 </span>            : #define ISUPPER(c) (ISASCII(c) &amp;&amp; isupper((int)(unsigned char)(c)))
<span class="lineNum">     299 </span>            : #define ISLOWER(c) (ISASCII(c) &amp;&amp; islower((int)(unsigned char)(c)))
<span class="lineNum">     300 </span>            : #define ISALNUM(c) (ISASCII(c) &amp;&amp; isalnum((int)(unsigned char)(c)))
<span class="lineNum">     301 </span>            : #define ISALPHA(c) (ISASCII(c) &amp;&amp; isalpha((int)(unsigned char)(c)))
<span class="lineNum">     302 </span>            : #define ISDIGIT(c) (ISASCII(c) &amp;&amp; isdigit((int)(unsigned char)(c)))
<span class="lineNum">     303 </span>            : #define ISXDIGIT(c) (ISASCII(c) &amp;&amp; isxdigit((int)(unsigned char)(c)))
<span class="lineNum">     304 </span>            : #define TOUPPER(c) (ISASCII(c) ? toupper((int)(unsigned char)(c)) : (c))
<span class="lineNum">     305 </span>            : #define TOLOWER(c) (ISASCII(c) ? tolower((int)(unsigned char)(c)) : (c))
<span class="lineNum">     306 </span>            : #endif
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            : mrb_value mrb_exc_new(mrb_state *mrb, struct RClass *c, const char *ptr, long len);
<span class="lineNum">     309 </span>            : void mrb_exc_raise(mrb_state *mrb, mrb_value exc);
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            : void mrb_raise(mrb_state *mrb, struct RClass *c, const char *msg);
<span class="lineNum">     312 </span>            : void mrb_raisef(mrb_state *mrb, struct RClass *c, const char *fmt, ...);
<span class="lineNum">     313 </span>            : void mrb_name_error(mrb_state *mrb, mrb_sym id, const char *fmt, ...);
<span class="lineNum">     314 </span>            : void mrb_warn(const char *fmt, ...);
<span class="lineNum">     315 </span>            : void mrb_bug(const char *fmt, ...);
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : /* macros to get typical exception objects
<span class="lineNum">     318 </span>            :    note:
<span class="lineNum">     319 </span>            :    + those E_* macros requires mrb_state* variable named mrb.
<span class="lineNum">     320 </span>            :    + exception objects obtained from those macros are local to mrb
<span class="lineNum">     321 </span>            : */
<span class="lineNum">     322 </span>            : #define E_RUNTIME_ERROR             (mrb_class_get(mrb, &quot;RuntimeError&quot;))
<span class="lineNum">     323 </span>            : #define E_TYPE_ERROR                (mrb_class_get(mrb, &quot;TypeError&quot;))
<span class="lineNum">     324 </span>            : #define E_ARGUMENT_ERROR            (mrb_class_get(mrb, &quot;ArgumentError&quot;))
<span class="lineNum">     325 </span>            : #define E_INDEX_ERROR               (mrb_class_get(mrb, &quot;IndexError&quot;))
<span class="lineNum">     326 </span>            : #define E_RANGE_ERROR               (mrb_class_get(mrb, &quot;RangeError&quot;))
<span class="lineNum">     327 </span>            : #define E_NAME_ERROR                (mrb_class_get(mrb, &quot;NameError&quot;))
<span class="lineNum">     328 </span>            : #define E_NOMETHOD_ERROR            (mrb_class_get(mrb, &quot;NoMethodError&quot;))
<span class="lineNum">     329 </span>            : #define E_SCRIPT_ERROR              (mrb_class_get(mrb, &quot;ScriptError&quot;))
<span class="lineNum">     330 </span>            : #define E_SYNTAX_ERROR              (mrb_class_get(mrb, &quot;SyntaxError&quot;))
<span class="lineNum">     331 </span>            : #define E_LOCALJUMP_ERROR           (mrb_class_get(mrb, &quot;LocalJumpError&quot;))
<span class="lineNum">     332 </span>            : #define E_REGEXP_ERROR              (mrb_class_get(mrb, &quot;RegexpError&quot;))
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : #define E_NOTIMP_ERROR              (mrb_class_get(mrb, &quot;NotImplementedError&quot;))
<span class="lineNum">     335 </span>            : #define E_FLOATDOMAIN_ERROR         (mrb_class_get(mrb, &quot;FloatDomainError&quot;))
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            : #define E_KEY_ERROR                 (mrb_class_get(mrb, &quot;KeyError&quot;))
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : mrb_value mrb_yield(mrb_state *mrb, mrb_value v, mrb_value blk);
<span class="lineNum">     340 </span>            : mrb_value mrb_yield_argv(mrb_state *mrb, mrb_value b, int argc, mrb_value *argv);
<span class="lineNum">     341 </span>            : mrb_value mrb_class_new_instance(mrb_state *mrb, int, mrb_value*, struct RClass *);
<span class="lineNum">     342 </span>            : mrb_value mrb_class_new_instance_m(mrb_state *mrb, mrb_value klass);
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : void mrb_gc_protect(mrb_state *mrb, mrb_value obj);
<span class="lineNum">     345 </span>            : mrb_value mrb_to_int(mrb_state *mrb, mrb_value val);
<span class="lineNum">     346 </span>            : void mrb_check_type(mrb_state *mrb, mrb_value x, enum mrb_vtype t);
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            : typedef enum call_type {
<span class="lineNum">     349 </span>            :     CALL_PUBLIC,
<span class="lineNum">     350 </span>            :     CALL_FCALL,
<span class="lineNum">     351 </span>            :     CALL_VCALL,
<span class="lineNum">     352 </span>            :     CALL_TYPE_MAX
<span class="lineNum">     353 </span>            : } call_type;
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            : void mrb_define_alias(mrb_state *mrb, struct RClass *klass, const char *name1, const char *name2);
<span class="lineNum">     356 </span>            : const char *mrb_class_name(mrb_state *mrb, struct RClass* klass);
<span class="lineNum">     357 </span>            : void mrb_define_global_const(mrb_state *mrb, const char *name, mrb_value val);
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : mrb_value mrb_block_proc(void);
<span class="lineNum">     360 </span>            : mrb_value mrb_attr_get(mrb_state *mrb, mrb_value obj, mrb_sym id);
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : int mrb_respond_to(mrb_state *mrb, mrb_value obj, mrb_sym mid);
<span class="lineNum">     363 </span>            : int mrb_obj_is_instance_of(mrb_state *mrb, mrb_value obj, struct RClass* c);
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            : /* memory pool implementation */
<span class="lineNum">     366 </span>            : typedef struct mrb_pool mrb_pool;
<span class="lineNum">     367 </span>            : struct mrb_pool* mrb_pool_open(mrb_state*);
<span class="lineNum">     368 </span>            : void mrb_pool_close(struct mrb_pool*);
<span class="lineNum">     369 </span>            : void* mrb_pool_alloc(struct mrb_pool*, size_t);
<span class="lineNum">     370 </span>            : void* mrb_pool_realloc(struct mrb_pool*, void*, size_t oldlen, size_t newlen);
<span class="lineNum">     371 </span>            : int mrb_pool_can_realloc(struct mrb_pool*, void*, size_t);
<span class="lineNum">     372 </span>            : void* mrb_alloca(mrb_state *mrb, size_t);
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : #if defined(__cplusplus)
<span class="lineNum">     375 </span>            : }  /* extern &quot;C&quot; { */
<span class="lineNum">     376 </span>            : #endif
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            : #endif  /* MRUBY_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
